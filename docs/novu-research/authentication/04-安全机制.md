# Novu 身份认证机制 - 安全机制

## 一、密码哈希

### 1.1 bcrypt 实现

Novu 使用 bcrypt 进行密码哈希，salt rounds 设为 10：

```typescript
// apps/api/src/app/auth/usecases/register/user-register.usecase.ts

import { hash } from 'bcrypt';

@Injectable()
export class UserRegister {
  async execute(command: UserRegisterCommand) {
    // 密码哈希：salt rounds = 10
    const passwordHash = await hash(command.password, 10);
    
    const user = await this.userRepository.create({
      email,
      firstName: command.firstName.toLowerCase(),
      lastName: command.lastName?.toLowerCase(),
      password: passwordHash,  // 存储哈希值
    });

    return {
      user: await this.userRepository.findById(user._id),
      token: await this.authService.generateUserToken(user),
    };
  }
}
```

### 1.2 密码验证

```typescript
// apps/api/src/app/auth/usecases/login/login.usecase.ts

import bcrypt from 'bcrypt';

@Injectable()
export class Login {
  async execute(command: LoginCommand) {
    const user = await this.userRepository.findByEmail(email);

    // 验证密码
    const isMatching = await bcrypt.compare(command.password, user.password);
    if (!isMatching) {
      // 处理失败尝试...
    }

    return {
      token: await this.authService.generateUserToken(user),
    };
  }
}
```

### 1.3 密码更新

```typescript
// apps/api/src/app/auth/usecases/update-password/update-password.usecase.ts

import { compare, hash } from 'bcrypt';

@Injectable()
export class UpdatePassword {
  async execute(command: UpdatePasswordCommand) {
    // 1. 验证两次密码一致
    if (command.newPassword !== command.confirmPassword) {
      throw new BadRequestException('Passwords do not match.');
    }

    const user = await this.userRepository.findById(command.userId);
    
    // 2. OAuth 用户不能修改密码
    if (!user.password) {
      throw new BadRequestException('OAuth user cannot change password.');
    }

    // 3. 验证当前密码
    const isAuthorized = await compare(command.currentPassword, user.password);
    if (!isAuthorized) {
      throw new UnauthorizedException();
    }

    // 4. 更新密码
    await this.setNewPassword(user._id, command.newPassword);

    // 5. 使缓存失效
    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({ _id: user._id }),
    });
  }

  private async setNewPassword(userId: string, newPassword: string) {
    const newPasswordHash = await hash(newPassword, 10);

    await this.userRepository.update(
      { _id: userId },
      { $set: { password: newPasswordHash } }
    );
  }
}
```

---

## 二、登录锁定机制

### 2.1 锁定策略

| 参数 | 值 | 说明 |
|:---|:---|:---|
| 最大失败次数 | 5 | 连续失败 5 次后锁定 |
| 锁定时长 | 5 分钟 | 锁定后需等待 5 分钟 |
| 提示阈值 | 剩余 3 次 | 剩余次数少于 3 次时提示 |

### 2.2 实现代码

```typescript
// apps/api/src/app/auth/usecases/login/login.usecase.ts

@Injectable()
export class Login {
  private BLOCKED_PERIOD_IN_MINUTES = 5;
  private MAX_LOGIN_ATTEMPTS = 5;

  async execute(command: LoginCommand) {
    const email = normalizeEmail(command.email);
    const user = await this.userRepository.findByEmail(email);

    // 不存在的用户：随机延迟防止时序攻击
    if (!user) {
      const maxWaitTime = 110;
      const minWaitTime = 90;
      const randomWaitTime = Math.floor(Math.random() * (maxWaitTime - minWaitTime) + minWaitTime);
      await new Promise((resolve) => setTimeout(resolve, randomWaitTime));

      throw new UnauthorizedException('Incorrect email or password provided.');
    }

    // 检查账户是否被锁定
    if (this.isAccountBlocked(user) && user.failedLogin) {
      const blockedMinutesLeft = this.getBlockedMinutesLeft(user.failedLogin.lastFailedAttempt);
      throw new UnauthorizedException(
        `Account blocked, Please try again after ${blockedMinutesLeft} minutes`
      );
    }

    // OAuth 用户提示
    if (!user.password) {
      throw new BadRequestException('Please sign in using Github.');
    }

    // 验证密码
    const isMatching = await bcrypt.compare(command.password, user.password);
    if (!isMatching) {
      // 更新失败次数
      const failedAttempts = await this.updateFailedAttempts(user);
      const remainingAttempts = this.MAX_LOGIN_ATTEMPTS - failedAttempts;

      // 账户被锁定
      if (remainingAttempts === 0 && user.failedLogin) {
        const blockedMinutesLeft = this.getBlockedMinutesLeft(user.failedLogin.lastFailedAttempt);
        throw new UnauthorizedException(
          `Account blocked, Please try again after ${blockedMinutesLeft} minutes`
        );
      }

      // 提示剩余次数
      if (remainingAttempts < 3) {
        throw new UnauthorizedException(
          `Incorrect email or password provided. ${remainingAttempts} Attempts left`
        );
      }

      throw new UnauthorizedException('Incorrect email or password provided.');
    }

    // 登录成功：重置失败计数
    if (user?.failedLogin && user?.failedLogin?.times > 0) {
      await this.resetFailedAttempts(user);
    }

    return {
      token: await this.authService.generateUserToken(user),
    };
  }

  /**
   * 检查账户是否被锁定
   */
  private isAccountBlocked(user: UserEntity) {
    const lastFailedAttempt = user?.failedLogin?.lastFailedAttempt;
    if (!lastFailedAttempt) return false;

    const diff = this.getTimeDiffForAttempt(lastFailedAttempt);

    return (
      user?.failedLogin && 
      user?.failedLogin?.times >= this.MAX_LOGIN_ATTEMPTS && 
      diff < this.BLOCKED_PERIOD_IN_MINUTES
    );
  }

  /**
   * 更新失败尝试次数
   */
  private async updateFailedAttempts(user: UserEntity) {
    const now = new Date();
    let times = user?.failedLogin?.times ?? 1;
    const lastFailedAttempt = user?.failedLogin?.lastFailedAttempt;

    if (lastFailedAttempt) {
      const diff = this.getTimeDiffForAttempt(lastFailedAttempt);
      // 如果超过锁定时间，重置计数
      times = diff < this.BLOCKED_PERIOD_IN_MINUTES ? times + 1 : 1;
    }

    await this.userRepository.update(
      { _id: user._id },
      {
        $set: {
          failedLogin: {
            times,
            lastFailedAttempt: now,
          },
        },
      }
    );

    return times;
  }

  /**
   * 重置失败计数
   */
  private async resetFailedAttempts(user: UserEntity) {
    await this.userRepository.update(
      { _id: user._id },
      { $set: { 'failedLogin.times': 0 } }
    );
  }

  /**
   * 计算距离上次失败的时间（分钟）
   */
  private getTimeDiffForAttempt(lastFailedAttempt: string) {
    const now = new Date();
    const formattedLastAttempt = parseISO(lastFailedAttempt);
    return differenceInMinutes(now, formattedLastAttempt);
  }

  /**
   * 计算剩余锁定时间
   */
  private getBlockedMinutesLeft(lastFailedAttempt: string) {
    const diff = this.getTimeDiffForAttempt(lastFailedAttempt);
    return this.BLOCKED_PERIOD_IN_MINUTES - diff;
  }
}
```

### 2.3 用户实体中的失败登录字段

```typescript
// User 实体中的 failedLogin 字段
interface FailedLogin {
  times: number;              // 失败次数
  lastFailedAttempt: string;  // 最后一次失败时间（ISO 字符串）
}

// UserEntity
interface UserEntity {
  // ... 其他字段
  failedLogin?: FailedLogin;
}
```

---

## 三、密码重置限流

### 3.1 限流策略

| 限制类型 | 时间窗口 | 最大次数 | 说明 |
|:---|:---|:---|:---|
| 分钟级限制 | 60 秒 | 5 次 | 防止短时间爆破 |
| 日级限制 | 24 小时 | 15 次 | 防止长期持续攻击 |

### 3.2 实现代码

```typescript
// apps/api/src/app/auth/usecases/password-reset-request/password-reset-request.usecase.ts

@Injectable()
export class PasswordResetRequest {
  private MAX_ATTEMPTS_IN_A_MINUTE = 5;
  private MAX_ATTEMPTS_IN_A_DAY = 15;
  private RATE_LIMIT_IN_SECONDS = 60;
  private RATE_LIMIT_IN_HOURS = 24;

  constructor(
    private invalidateCache: InvalidateCacheService,
    private userRepository: UserRepository
  ) {}

  async execute(command: PasswordResetRequestCommand): Promise<{ success: boolean }> {
    const email = normalizeEmail(command.email);
    const foundUser = await this.userRepository.findByEmail(email);

    if (foundUser && foundUser.email) {
      // 检查是否被限流
      const { error, isBlocked } = this.isRequestBlocked(foundUser);
      if (isBlocked) {
        throw new UnauthorizedException(error);
      }

      // 生成重置 Token
      const token = uuidv4();

      // 使缓存失效
      await this.invalidateCache.invalidateByKey({
        key: buildUserKey({ _id: foundUser._id }),
      });

      // 更新请求计数
      const resetTokenCount = this.getUpdatedRequestCount(foundUser);
      await this.userRepository.updatePasswordResetToken(foundUser._id, token, resetTokenCount);

      // 发送重置邮件（生产环境）
      if (
        (process.env.NODE_ENV === 'dev' || process.env.NODE_ENV === 'production') && 
        process.env.NOVU_API_KEY
      ) {
        const resetPasswordLink = PasswordResetRequest.getResetRedirectLink(
          token, 
          foundUser, 
          command.src
        );
        // 发送邮件逻辑...
      }
    }

    // 无论用户是否存在都返回成功（防止用户枚举）
    return { success: true };
  }

  /**
   * 检查请求是否被限流
   */
  private isRequestBlocked(user: UserEntity) {
    const lastResetAttempt = user.resetTokenDate;

    if (!lastResetAttempt) {
      return { isBlocked: false, error: '' };
    }

    const formattedDate = parseISO(lastResetAttempt);
    const diffSeconds = differenceInSeconds(new Date(), formattedDate);
    const diffHours = differenceInHours(new Date(), formattedDate);

    // 检查日级限制
    const withinDailyLimit = diffHours < this.RATE_LIMIT_IN_HOURS;
    const exceededDailyAttempt = user?.resetTokenCount
      ? user?.resetTokenCount?.reqInDay >= this.MAX_ATTEMPTS_IN_A_DAY
      : false;

    if (withinDailyLimit && exceededDailyAttempt) {
      return {
        isBlocked: true,
        error: `Too many requests, Try again after ${this.RATE_LIMIT_IN_HOURS} hours.`,
      };
    }

    // 检查分钟级限制
    const withinMinuteLimit = diffSeconds < this.RATE_LIMIT_IN_SECONDS;
    const exceededMinuteAttempt = user?.resetTokenCount
      ? user?.resetTokenCount?.reqInMinute >= this.MAX_ATTEMPTS_IN_A_MINUTE
      : false;

    if (withinMinuteLimit && exceededMinuteAttempt) {
      return {
        isBlocked: true,
        error: 'Too many requests, Try again after a minute.',
      };
    }

    return { isBlocked: false, error: '' };
  }

  /**
   * 获取更新后的请求计数
   */
  private getUpdatedRequestCount(user: UserEntity): IUserResetTokenCount {
    const now = new Date().toISOString();
    const lastResetAttempt = user.resetTokenDate ?? now;
    const formattedDate = parseISO(lastResetAttempt);
    const diffSeconds = differenceInSeconds(new Date(), formattedDate);
    const diffHours = differenceInHours(new Date(), formattedDate);

    const resetTokenCount: IUserResetTokenCount = {
      reqInMinute: user.resetTokenCount?.reqInMinute ?? 0,
      reqInDay: user.resetTokenCount?.reqInDay ?? 0,
    };

    // 根据时间窗口决定是递增还是重置
    resetTokenCount.reqInMinute = 
      diffSeconds < this.RATE_LIMIT_IN_SECONDS 
        ? resetTokenCount.reqInMinute + 1 
        : 1;
    resetTokenCount.reqInDay = 
      diffHours < this.RATE_LIMIT_IN_HOURS 
        ? resetTokenCount.reqInDay + 1 
        : 1;

    return resetTokenCount;
  }

  /**
   * 生成重置链接
   */
  private static getResetRedirectLink(
    token: string, 
    user: UserEntity, 
    src?: PasswordResetFlowEnum
  ): string {
    // 用户资料页面设置密码（仅限无密码用户）
    if (src === PasswordResetFlowEnum.USER_PROFILE && !user.password) {
      return `${process.env.FRONT_BASE_URL}/settings/profile?token=${token}&view=password`;
    }

    // 默认：忘记密码流程
    return `${process.env.FRONT_BASE_URL}/auth/reset/${token}`;
  }
}
```

### 3.3 用户实体中的重置 Token 字段

```typescript
interface IUserResetTokenCount {
  reqInMinute: number;  // 分钟内请求数
  reqInDay: number;     // 日内请求数
}

// UserEntity
interface UserEntity {
  // ... 其他字段
  resetToken?: string;           // 重置 Token
  resetTokenDate?: string;       // 重置 Token 创建时间
  resetTokenCount?: IUserResetTokenCount;  // 请求计数
}
```

---

## 四、CORS 配置

### 4.1 CORS 配置策略

```typescript
// apps/api/src/config/cors.config.ts

import { INestApplication } from '@nestjs/common';
import { HttpRequestHeaderKeysEnum } from '@novu/application-generic';

// 允许的源（正则匹配）
const ALLOWED_ORIGINS_REGEX = new RegExp(process.env.FRONT_BASE_URL || '');

export const corsOptionsDelegate: Parameters<INestApplication['enableCors']>[0] = (
  req: Request, 
  callback
) => {
  const corsOptions: Parameters<typeof callback>[1] = {
    origin: false as boolean | string | string[],
    preflightContinue: false,
    maxAge: 86400,              // 预检缓存 24 小时
    credentials: true,          // 允许携带凭证
    allowedHeaders: Object.values(HttpRequestHeaderKeysEnum),
    methods: ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  };

  if (enableWildcard(req)) {
    // 允许通配符（开发环境或特定路由）
    corsOptions.origin = '*';
  } else {
    // 生产环境：严格的源验证
    corsOptions.origin = [];

    const requestOrigin = origin(req);

    // 匹配前端 URL
    if (ALLOWED_ORIGINS_REGEX.test(requestOrigin)) {
      corsOptions.origin.push(requestOrigin);
    }

    // Widget URL
    if (process.env.WIDGET_BASE_URL) {
      corsOptions.origin.push(process.env.WIDGET_BASE_URL);
    }

    // 文档 URL
    if (process.env.DOCS_BASE_URL) {
      corsOptions.origin.push(process.env.DOCS_BASE_URL);
    }
  }

  callback(null as unknown as Error, corsOptions);
};
```

### 4.2 通配符启用条件

```typescript
/**
 * 启用通配符 CORS 的条件
 * 满足以下条件之一：
 * 1. 开发/测试环境
 * 2. Widget 路由
 * 3. Inbox 路由
 * 4. Blueprint 路由
 * 
 * 注意：Better Auth 路由始终排除通配符
 */
function enableWildcard(req: Request): boolean {
  return (
    (isDevelopmentEnvironment() || 
     isWidgetRoute(req.url) || 
     isInboxRoute(req.url) || 
     isBlueprintRoute(req.url)) &&
    !isBetterAuthRoute(req.url)  // ★ Better Auth 路由必须严格验证
  );
}

function isDevelopmentEnvironment(): boolean {
  return ['test', 'local'].includes(process.env.NODE_ENV || '');
}

function isWidgetRoute(url: string): boolean {
  return url.startsWith('/v1/widgets');
}

function isInboxRoute(url: string): boolean {
  return url.startsWith('/v1/inbox');
}

function isBlueprintRoute(url: string): boolean {
  return url.startsWith('/v1/blueprints');
}

function isBetterAuthRoute(url: string): boolean {
  return url.startsWith('/v1/better-auth');
}

function origin(req: Request): string {
  return (req.headers as any)?.origin || '';
}
```

### 4.3 Bootstrap 中的 CORS 启用

```typescript
// apps/api/src/bootstrap.ts

export async function bootstrap(): Promise<{ app: INestApplication; document: any }> {
  const app = await NestFactory.create(AppModule, { bufferLogs: true, ...nestOptions });

  // 启用 Helmet 安全头
  app.use(helmet());

  // 启用 CORS（使用委托函数）
  app.enableCors(corsOptionsDelegate);

  // 其他中间件...
}
```

### 4.4 CORS 配置表格

| 场景 | Origin 设置 | 凭证 | 说明 |
|:---|:---|:---|:---|
| 开发环境 | `*` | ✓ | 所有源允许 |
| Widget 路由 | `*` | ✓ | 嵌入式组件 |
| Inbox 路由 | `*` | ✓ | 收件箱组件 |
| Blueprint 路由 | `*` | ✓ | 蓝图 API |
| Better Auth 路由 | 严格验证 | ✓ | 必须精确匹配 |
| 生产环境 | 白名单 | ✓ | 仅允许配置的源 |

---

## 五、其他安全措施

### 5.1 邮箱规范化

```typescript
// packages/shared/src/utils/email.ts

import normalizeEmail from 'normalize-email';

/**
 * 规范化邮箱地址
 * - 转换为小写
 * - 去除 Gmail 别名（+号）
 * - 去除 Googlemail 域名差异
 */
export const normalizeEmail = (email: string): string => {
  return normalizeEmail(email.toLowerCase().trim());
};
```

### 5.2 用户注册开关

```typescript
// apps/api/src/app/auth/usecases/register/user-register.usecase.ts

async execute(command: UserRegisterCommand) {
  // 可通过环境变量禁用注册
  if (process.env.DISABLE_USER_REGISTRATION === 'true') {
    throw new BadRequestException('Account creation is disabled');
  }

  // 检查邮箱是否已存在
  const email = normalizeEmail(command.email);
  const existingUser = await this.userRepository.findByEmail(email);
  if (existingUser) {
    throw new BadRequestException('User already exists');
  }

  // 创建用户...
}
```

### 5.3 Helmet 安全头

```typescript
// apps/api/src/bootstrap.ts

import helmet from 'helmet';

export async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 启用 Helmet 设置安全相关的 HTTP 头
  // 包括：
  // - X-Content-Type-Options: nosniff
  // - X-Frame-Options: SAMEORIGIN
  // - X-XSS-Protection: 1; mode=block
  // - Strict-Transport-Security (HSTS)
  app.use(helmet());
}
```

---

## 六、安全机制总结

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           Novu 安全机制总览                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         密码安全                                     │    │
│  │                                                                      │    │
│  │  bcrypt + salt rounds 10                                            │    │
│  │  ├── 注册时哈希存储                                                  │    │
│  │  ├── 登录时比较验证                                                  │    │
│  │  └── 更新时重新哈希                                                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         登录保护                                     │    │
│  │                                                                      │    │
│  │  失败 5 次 → 锁定 5 分钟                                             │    │
│  │  ├── 记录失败次数和时间                                              │    │
│  │  ├── 剩余 3 次以下时提示                                             │    │
│  │  ├── 登录成功重置计数                                                │    │
│  │  └── 不存在用户随机延迟（防时序攻击）                                 │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                       密码重置限流                                   │    │
│  │                                                                      │    │
│  │  分钟级：5 次 / 60 秒                                                │    │
│  │  日级：15 次 / 24 小时                                               │    │
│  │  ├── 窗口内递增计数                                                  │    │
│  │  ├── 超窗口重置计数                                                  │    │
│  │  └── 无论用户存在与否返回成功（防枚举）                               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                         CORS 保护                                    │    │
│  │                                                                      │    │
│  │  开发环境 → 通配符允许                                               │    │
│  │  生产环境 → 白名单验证                                               │    │
│  │  Better Auth → 严格 Origin 验证                                      │    │
│  │  公开路由 → Widget/Inbox/Blueprint 通配                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                       其他安全措施                                   │    │
│  │                                                                      │    │
│  │  Helmet → 安全 HTTP 头                                              │    │
│  │  邮箱规范化 → 统一格式处理                                           │    │
│  │  注册开关 → 可禁用注册                                               │    │
│  │  OAuth 提示 → 区分认证方式                                           │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

---

*文档版本：1.0*  
*更新时间：2026-02-22*
