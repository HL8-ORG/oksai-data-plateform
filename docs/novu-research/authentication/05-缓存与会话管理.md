# Novu 身份认证机制 - 缓存与会话管理

## 一、LRU 缓存架构

### 1.1 缓存服务概述

Novu 使用内存 LRU（Least Recently Used）缓存来优化认证过程中的数据查询，减少数据库访问。

```typescript
// libs/application-generic/src/services/in-memory-lru-cache/in-memory-lru-cache.service.ts

import { Injectable } from '@nestjs/common';
import { LRUCache } from 'lru-cache';

type EntityStore<T = unknown> = {
  cache: LRUCache<string, T>;           // LRU 缓存实例
  inflightRequests: Map<string, Promise<T>>;  // 进行中的请求（防并发）
  config: StoreConfig;                   // 存储配置
};

// 全局存储映射（进程内单例）
const STORES = new Map<string, EntityStore>();

@Injectable()
export class InMemoryLRUCacheService {
  constructor(private featureFlagsService: FeatureFlagsService) {}

  /**
   * 获取缓存数据（支持自动加载和并发控制）
   */
  async get<TStore extends InMemoryLRUCacheStore>(
    storeName: TStore,
    key: string,
    fetchFn: () => Promise<CacheStoreDataTypeMap[TStore]>,
    opts?: GetOptions
  ): Promise<CacheStoreDataTypeMap[TStore]> {
    const store = this.getOrCreateStore<CacheStoreDataTypeMap[TStore]>(storeName);
    const isCacheEnabled = await this.isCacheEnabled(store.config, opts);

    // 缓存禁用或跳过时直接获取
    if (!isCacheEnabled || opts?.skipCache) {
      return fetchFn();
    }

    const effectiveKey = this.resolveKey(key, opts?.cacheVariant);

    // 1. 检查缓存
    const cached = store.cache.get(effectiveKey);
    if (cached !== undefined) {
      return cached;
    }

    // 2. 检查是否有进行中的相同请求（防止缓存穿透）
    const inflightRequest = store.inflightRequests.get(effectiveKey);
    if (inflightRequest) {
      return inflightRequest;
    }

    // 3. 发起新请求
    const fetchPromise = fetchFn()
      .then((result) => {
        if (result !== null && result !== undefined) {
          store.cache.set(effectiveKey, result);
        }
        return result;
      })
      .finally(() => {
        store.inflightRequests.delete(effectiveKey);
      });

    store.inflightRequests.set(effectiveKey, fetchPromise);

    return fetchPromise;
  }

  /**
   * 获取已缓存的数据（不触发加载）
   */
  getIfCached<TStore extends InMemoryLRUCacheStore>(
    storeName: TStore,
    key: string
  ): CacheStoreDataTypeMap[TStore] | undefined {
    const store = STORES.get(storeName);
    if (!store) {
      return undefined;
    }
    return store.cache.get(key) as CacheStoreDataTypeMap[TStore] | undefined;
  }

  /**
   * 使指定键失效
   */
  invalidate(storeName: InMemoryLRUCacheStore, key: string): void {
    const store = STORES.get(storeName);
    if (!store) return;

    for (const cacheKey of store.cache.keys()) {
      if (cacheKey === key || cacheKey.startsWith(`${key}:v:`)) {
        store.cache.delete(cacheKey);
      }
    }
  }

  /**
   * 使整个存储失效
   */
  invalidateAll(storeName: InMemoryLRUCacheStore): void {
    const store = STORES.get(storeName);
    if (store) {
      store.cache.clear();
      store.inflightRequests.clear();
    }
  }

  /**
   * 手动设置缓存值
   */
  set<TStore extends InMemoryLRUCacheStore>(
    storeName: TStore,
    key: string,
    value: CacheStoreDataTypeMap[TStore]
  ): void {
    const store = this.getOrCreateStore<CacheStoreDataTypeMap[TStore]>(storeName);
    store.cache.set(key, value);
  }

  private resolveKey(key: string, cacheVariant?: string): string {
    return cacheVariant ? `${key}:v:${cacheVariant}` : key;
  }

  private getOrCreateStore<T>(storeName: InMemoryLRUCacheStore): EntityStore<T> {
    let store = STORES.get(storeName) as EntityStore<T> | undefined;

    if (!store) {
      const config = STORE_CONFIGS[storeName];
      store = {
        cache: new LRUCache<string, T>({
          max: config.max,
          ttl: config.ttl,
        }),
        inflightRequests: new Map<string, Promise<T>>(),
        config,
      };
      STORES.set(storeName, store as EntityStore);
    }

    return store;
  }

  private async isCacheEnabled(config: StoreConfig, opts?: GetOptions): Promise<boolean> {
    if (config.skipFeatureFlag) {
      return true;
    }

    if (!opts?.environmentId && !opts?.organizationId) {
      return false;
    }

    try {
      const flag = await this.featureFlagsService.getFlag({
        key: FeatureFlagsKeysEnum.IS_LRU_CACHE_ENABLED,
        defaultValue: false,
        component: config.featureFlagComponent,
        ...(opts.environmentId && { environment: { _id: opts.environmentId } }),
        ...(opts.organizationId && { organization: { _id: opts.organizationId } }),
      });
      return flag;
    } catch {
      return false;
    }
  }
}
```

### 1.2 缓存存储类型定义

```typescript
// libs/application-generic/src/services/in-memory-lru-cache/in-memory-lru-cache.store.ts

import type { 
  EnvironmentEntity, 
  NotificationTemplateEntity, 
  OrganizationEntity, 
  PreferencesEntity 
} from '@novu/dal';
import type { UserSessionData } from '@novu/shared';

/**
 * 缓存存储枚举
 */
export enum InMemoryLRUCacheStore {
  WORKFLOW = 'workflow',
  ORGANIZATION = 'organization',
  ENVIRONMENT = 'environment',
  API_KEY_USER = 'api-key-user',
  VALIDATOR = 'validator',
  ACTIVE_WORKFLOWS = 'active-workflows',
  WORKFLOW_PREFERENCES = 'workflow-preferences',
}

/**
 * 各存储的数据类型
 */
export type WorkflowCacheData = NotificationTemplateEntity | null;
export type OrganizationCacheData = OrganizationEntity | null;
export type EnvironmentCacheData = Pick<EnvironmentEntity, '_id' | 'echo' | 'apiKeys'> | null;
export type ApiKeyUserCacheData = UserSessionData | null;
export type ValidatorCacheData = unknown;
export type ActiveWorkflowsCacheData = NotificationTemplateEntity[];
export type WorkflowPreferencesCacheData = [PreferencesEntity | null, PreferencesEntity | null];

/**
 * 存储类型映射
 */
export type CacheStoreDataTypeMap = {
  [InMemoryLRUCacheStore.WORKFLOW]: WorkflowCacheData;
  [InMemoryLRUCacheStore.ORGANIZATION]: OrganizationCacheData;
  [InMemoryLRUCacheStore.ENVIRONMENT]: EnvironmentCacheData;
  [InMemoryLRUCacheStore.API_KEY_USER]: ApiKeyUserCacheData;
  [InMemoryLRUCacheStore.VALIDATOR]: ValidatorCacheData;
  [InMemoryLRUCacheStore.ACTIVE_WORKFLOWS]: ActiveWorkflowsCacheData;
  [InMemoryLRUCacheStore.WORKFLOW_PREFERENCES]: WorkflowPreferencesCacheData;
};

/**
 * 存储配置
 */
export type StoreConfig = {
  max: number;              // 最大条目数
  ttl: number;              // 过期时间（毫秒）
  featureFlagComponent: string;  // 功能开关组件名
  skipFeatureFlag?: boolean;     // 是否跳过功能开关检查
};

/**
 * 各存储的配置
 */
export const STORE_CONFIGS: Record<InMemoryLRUCacheStore, StoreConfig> = {
  [InMemoryLRUCacheStore.WORKFLOW]: {
    max: 1000,
    ttl: 1000 * 30,  // 30 秒
    featureFlagComponent: 'workflow',
  },
  [InMemoryLRUCacheStore.ORGANIZATION]: {
    max: 500,
    ttl: 1000 * 60,  // 60 秒
    featureFlagComponent: 'organization',
  },
  [InMemoryLRUCacheStore.ENVIRONMENT]: {
    max: 500,
    ttl: 1000 * 60,  // 60 秒
    featureFlagComponent: 'environment',
  },
  [InMemoryLRUCacheStore.API_KEY_USER]: {
    max: 1000,
    ttl: 1000 * 60,  // 60 秒
    featureFlagComponent: 'api-key-user',
  },
  [InMemoryLRUCacheStore.VALIDATOR]: {
    max: 5000,
    ttl: 1000 * 60 * 60,  // 1 小时
    featureFlagComponent: 'validator',
    skipFeatureFlag: true,  // 始终启用
  },
  [InMemoryLRUCacheStore.ACTIVE_WORKFLOWS]: {
    max: 300,
    ttl: 1000 * 60,  // 60 秒
    featureFlagComponent: 'active-workflows',
  },
  [InMemoryLRUCacheStore.WORKFLOW_PREFERENCES]: {
    max: 1000,
    ttl: 1000 * 60,  // 60 秒
    featureFlagComponent: 'workflow-preferences',
  },
};
```

### 1.3 缓存配置汇总表

| 存储类型 | 最大条目 | TTL | 功能开关 | 用途 |
|:---|:---|:---|:---|:---|
| WORKFLOW | 1000 | 30s | ✓ | Workflow 模板缓存 |
| ORGANIZATION | 500 | 60s | ✓ | 组织信息缓存 |
| ENVIRONMENT | 500 | 60s | ✓ | 环境配置缓存 |
| API_KEY_USER | 1000 | 60s | ✓ | API Key 用户会话 |
| VALIDATOR | 5000 | 1h | 跳过 | 验证器缓存 |
| ACTIVE_WORKFLOWS | 300 | 60s | ✓ | 活跃 Workflow 列表 |
| WORKFLOW_PREFERENCES | 1000 | 60s | ✓ | Workflow 偏好设置 |

---

## 二、API Key 认证缓存

### 2.1 ApiKeyStrategy 缓存使用

```typescript
// apps/api/src/app/auth/services/passport/apikey.strategy.ts

@Injectable()
export class ApiKeyStrategy extends PassportStrategy(HeaderAPIKeyStrategy, 'headerapikey') {
  constructor(
    private environmentRepository: EnvironmentRepository,
    private userRepository: UserRepository,
    private memberRepository: MemberRepository,
    private inMemoryLRUCacheService: InMemoryLRUCacheService
  ) {
    super(
      {
        header: 'Authorization',
        prefix: 'ApiKey',
      },
      true,
      async (apiKey: string, verified: VerifyCallback) => {
        // 验证逻辑...
      }
    );
  }

  async validate(apiKey: string, request: any): Promise<UserSessionData> {
    // 1. 计算缓存键
    const cacheKey = this.buildApiKeyCacheKey(apiKey);

    // 2. 尝试从缓存获取
    const cachedSession = this.inMemoryLRUCacheService.getIfCached(
      InMemoryLRUCacheStore.API_KEY_USER,
      cacheKey
    );

    if (cachedSession) {
      return cachedSession;
    }

    // 3. 缓存未命中，查询数据库
    const { userId, organizationId, environment } = 
      await this.getUserOrganizationEnvironment(apiKey);

    // 4. 获取用户和成员信息
    const user = await this.userRepository.findById(userId);
    const member = await this.memberRepository.findMemberByUserId(organizationId, userId);

    // 5. 构建会话数据
    const sessionData: UserSessionData = {
      _id: userId,
      firstName: user?.firstName,
      lastName: user?.lastName,
      email: user?.email,
      organizationId,
      environmentId: environment._id,
      roles: member?.roles || [],
      permissions: member ? this.getMemberPermissions(member.roles) : [],
      scheme: ApiAuthSchemeEnum.API_KEY,
    };

    // 6. 存入缓存
    await this.inMemoryLRUCacheService.set(
      InMemoryLRUCacheStore.API_KEY_USER,
      cacheKey,
      sessionData
    );

    return sessionData;
  }

  private buildApiKeyCacheKey(apiKey: string): string {
    // 使用 API Key 的哈希值作为缓存键
    const hash = crypto.createHash('sha256').update(apiKey).digest('hex');
    return `api-key:${hash}`;
  }
}
```

### 2.2 缓存失效策略

```typescript
// libs/application-generic/src/services/cache/invalidate-cache.service.ts

@Injectable()
export class InvalidateCacheService {
  constructor(private inMemoryLRUCacheService: InMemoryLRUCacheService) {}

  /**
   * 使指定键的缓存失效
   */
  async invalidateByKey(params: { key: string }): Promise<void> {
    // 根据键前缀判断存储类型
    if (params.key.startsWith('user:')) {
      this.inMemoryLRUCacheService.invalidate(
        InMemoryLRUCacheStore.API_KEY_USER,
        params.key
      );
    } else if (params.key.startsWith('organization:')) {
      this.inMemoryLRUCacheService.invalidate(
        InMemoryLRUCacheStore.ORGANIZATION,
        params.key
      );
    }
    // ... 其他存储类型
  }
}

// 使用示例：更新密码后使缓存失效
@Injectable()
export class UpdatePassword {
  constructor(private invalidateCache: InvalidateCacheService) {}

  async execute(command: UpdatePasswordCommand) {
    // 更新密码...
    await this.setNewPassword(user._id, command.newPassword);

    // 使用户缓存失效
    await this.invalidateCache.invalidateByKey({
      key: buildUserKey({ _id: user._id }),
    });
  }
}
```

---

## 三、会话上下文传递

### 3.1 UserSessionData 类型

```typescript
// packages/shared/src/types/auth.ts

export type UserSessionData = {
  // 用户基本信息
  _id: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  profilePicture?: string;

  // 租户信息（核心）
  organizationId: string;              // 当前组织 ID
  environmentId: string;               // 当前环境 ID

  // 权限信息
  roles: MemberRoleEnum[];             // 角色列表
  permissions: PermissionsEnum[];      // 权限列表

  // 认证方案
  scheme: ApiAuthSchemeEnum;           // Bearer / ApiKey / Keyless
};

export enum ApiAuthSchemeEnum {
  BEARER = 'Bearer',
  API_KEY = 'ApiKey',
  KEYLESS = 'Keyless',
}
```

### 3.2 @UserSession 装饰器

```typescript
// libs/application-generic/src/decorators/user-session.decorator.ts

import { createParamDecorator, ExecutionContext, InternalServerErrorException } from '@nestjs/common';
import { Logger } from '@novu/application-generic';

/**
 * 从请求中提取用户会话数据
 * 支持 HTTP 和 GraphQL 两种上下文
 */
export const UserSession = createParamDecorator((data, ctx: ExecutionContext) => {
  let req;

  // 支持多种上下文类型
  if (ctx.getType() === 'graphql') {
    // GraphQL 上下文
    req = ctx.getArgs()[2].req;
  } else {
    // HTTP 上下文
    req = ctx.switchToHttp().getRequest();
  }

  if (req.user) {
    return req.user;
  }

  Logger.error(
    'Attempted to access user session without a user in the request. ' +
    'You probably forgot to add the AuthGuard',
    'UserSession'
  );
  throw new InternalServerErrorException();
});
```

### 3.3 Controller 层使用

```typescript
// 典型 Controller 使用示例
@Controller('workflows')
export class WorkflowController {
  constructor(private createWorkflow: CreateWorkflow) {}

  @Post()
  @RequireAuthentication()
  async create(
    @UserSession() user: UserSessionData,  // 自动注入会话数据
    @Body() dto: CreateWorkflowDto
  ) {
    // 用户上下文自动传递到用例层
    return this.createWorkflow.execute({
      userId: user._id,
      organizationId: user.organizationId,
      environmentId: user.environmentId,
      ...dto,
    });
  }

  @Get()
  @RequireAuthentication()
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  async list(
    @UserSession() user: UserSessionData,
    @Query() query: ListWorkflowsQuery
  ) {
    return this.listWorkflows.execute({
      organizationId: user.organizationId,
      environmentId: user.environmentId,
      ...query,
    });
  }
}
```

### 3.4 UseCase 层使用

```typescript
// apps/api/src/app/workflow/usecases/create-workflow/create-workflow.command.ts

export class CreateWorkflowCommand {
  // 从会话注入的字段
  userId: string;
  organizationId: string;
  environmentId: string;

  // 业务字段
  name: string;
  description?: string;
  // ...
}

// apps/api/src/app/workflow/usecases/create-workflow/create-workflow.usecase.ts

@Injectable()
export class CreateWorkflow {
  constructor(
    private workflowRepository: WorkflowRepository,
    private auditService: AuditService
  ) {}

  async execute(command: CreateWorkflowCommand) {
    // 1. 多租户隔离：使用 organizationId 过滤
    // 2. 审计追踪：记录 userId
    // 3. 环境隔离：使用 environmentId

    const workflow = await this.workflowRepository.create({
      _organizationId: command.organizationId,
      _environmentId: command.environmentId,
      name: command.name,
      description: command.description,
      createdBy: command.userId,
    });

    // 审计日志
    await this.auditService.track({
      event: 'workflow_created',
      userId: command.userId,
      organizationId: command.organizationId,
      resourceId: workflow._id,
    });

    return workflow;
  }
}
```

---

## 四、缓存与会话流程图

### 4.1 完整认证流程（含缓存）

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                      认证流程与缓存交互                                        │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────┐                                                            │
│  │   客户端    │  Authorization: ApiKey xxx                                 │
│  └──────┬──────┘                                                            │
│         │                                                                    │
│         ▼                                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      ApiKeyStrategy                                  │   │
│  │                                                                      │   │
│  │  1. 计算 API Key 哈希                                                │   │
│  │     hash = SHA256(apiKey)                                            │   │
│  │     cacheKey = `api-key:${hash}`                                     │   │
│  │                                                                      │   │
│  │  2. 检查 LRU 缓存                                                    │   │
│  │     ┌─────────────────────────────────────────────────────────┐     │   │
│  │     │  InMemoryLRUCacheService.getIfCached(API_KEY_USER)     │     │   │
│  │     └─────────────────────────────────────────────────────────┘     │   │
│  │                        │                                             │   │
│  │            ┌───────────┴───────────┐                                 │   │
│  │            │                       │                                 │   │
│  │        命中 ▼                   未命中 ▼                              │   │
│  │  ┌─────────────────┐      ┌─────────────────────┐                   │   │
│  │  │ 返回缓存的      │      │ 查询数据库：         │                   │   │
│  │  │ UserSessionData │      │ - Environment       │                   │   │
│  │  └─────────────────┘      │ - User              │                   │   │
│  │                           │ - Member            │                   │   │
│  │                           └──────────┬──────────┘                   │   │
│  │                                      │                               │   │
│  │                                      ▼                               │   │
│  │                           ┌─────────────────────┐                   │   │
│  │                           │ 构建会话数据        │                   │   │
│  │                           │ 存入 LRU 缓存       │                   │   │
│  │                           │ TTL: 60s           │                   │   │
│  │                           └─────────────────────┘                   │   │
│  │                                                                      │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                       UserSessionData                                │   │
│  │                                                                      │   │
│  │  {                                                                   │   │
│  │    _id: "user_123",                                                  │   │
│  │    organizationId: "org_456",                                        │   │
│  │    environmentId: "env_789",                                         │   │
│  │    roles: ["admin"],                                                 │   │
│  │    permissions: ["workflow:read", "workflow:write"],                │   │
│  │    scheme: "ApiKey"                                                  │   │
│  │  }                                                                   │   │
│  │                                                                      │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      request.user = sessionData                      │   │
│  └────────────────────────────────┬────────────────────────────────────┘   │
│                                   │                                         │
│                                   ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Controller / UseCase                            │   │
│  │                                                                      │   │
│  │  @UserSession() user: UserSessionData                               │   │
│  │                                                                      │   │
│  │  - user.organizationId → 多租户隔离                                  │   │
│  │  - user.environmentId → 环境隔离                                     │   │
│  │  - user.permissions → 权限检查                                       │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 缓存失效时机

| 触发事件 | 失效的缓存 | 说明 |
|:---|:---|:---|
| 用户密码更新 | API_KEY_USER | 用户信息变更 |
| 组织信息更新 | ORGANIZATION | 组织配置变更 |
| 环境配置更新 | ENVIRONMENT | 环境设置变更 |
| Workflow 更新 | WORKFLOW | 模板变更 |
| 成员角色变更 | API_KEY_USER | 权限变更 |

---

## 五、最佳实践

### 5.1 缓存使用建议

1. **热点数据缓存**：频繁访问的用户、组织、环境数据
2. **合理设置 TTL**：根据数据变更频率设置
3. **主动失效**：数据变更时及时使缓存失效
4. **并发控制**：使用 inflightRequests 防止缓存穿透

### 5.2 会话传递规范

1. **Controller 层**：使用 `@UserSession()` 装饰器
2. **UseCase 层**：Command 包含 userId、organizationId、environmentId
3. **Repository 层**：查询时始终携带 organizationId 过滤
4. **审计追踪**：记录 userId 用于审计

---

*文档版本：1.0*  
*更新时间：2026-02-22*
