# Novu 多租户技术方案 - 策略与最佳实践

## 一、隔离策略

### 1.1 数据库隔离策略

#### 策略选择：共享数据库 + 行级隔离

```
┌─────────────────────────────────────────────────────────────────────┐
│                     隔离策略对比                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   策略 A: 独立数据库                                                 │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │  Org 1 DB    Org 2 DB    Org 3 DB                           │  │
│   │  ┌─────┐     ┌─────┐     ┌─────┐                            │  │
│   │  │Data │     │Data │     │Data │                            │  │
│   │  └─────┘     └─────┘     └─────┘                            │  │
│   └─────────────────────────────────────────────────────────────┘  │
│   优点：完全隔离、安全性高                                           │
│   缺点：成本高、运维复杂、跨租户分析难                               │
│                                                                      │
│   策略 B: 共享数据库 + 行级隔离 ✓ Novu 选择                         │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                      Shared DB                               │  │
│   │  ┌───────────────────────────────────────────────────────┐ │  │
│   │  │ org_id: 1 | org_id: 1 | org_id: 2 | org_id: 2 | ...  │ │  │
│   │  └───────────────────────────────────────────────────────┘ │  │
│   └─────────────────────────────────────────────────────────────┘  │
│   优点：成本低、运维简单、跨租户分析方便                             │
│   缺点：需要严格的查询过滤、潜在性能影响                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

#### 选择理由

| 考量因素 | Novu 选择 | 理由 |
|:---|:---|:---|
| **成本** | 共享数据库 | 降低基础设施成本 |
| **数据量** | 中等 | 单租户数据量不大，共享数据库可承受 |
| **隔离需求** | 行级隔离 | 通过代码强制隔离，满足安全要求 |
| **分析需求** | 跨租户分析 | 共享数据库便于全局统计 |
| **运维复杂度** | 低 | 单一数据库更易维护 |

### 1.2 三层隔离策略

```
┌─────────────────────────────────────────────────────────────────────┐
│                        三层隔离策略                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   Layer 1: Organization（组织层）                                    │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   隔离策略：完全隔离                                          │  │
│   │   隔离字段：_organizationId                                   │  │
│   │   数据范围：所有组织数据                                       │  │
│   │   典型场景：计费、品牌、成员管理                               │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   Layer 2: Environment（环境层）                                     │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   隔离策略：环境隔离                                          │  │
│   │   隔离字段：_environmentId                                    │  │
│   │   数据范围：工作流、订阅者、消息、集成配置                     │  │
│   │   典型场景：开发/生产环境分离                                  │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   Layer 3: Tenant（终端租户层）                                      │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   隔离策略：上下文隔离                                        │  │
│   │   隔离字段：contextKeys[]                                     │  │
│   │   数据范围：Inbox 消息、订阅者数据                            │  │
│   │   典型场景：SaaS 平台终端客户隔离                              │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 二、安全策略

### 2.1 类型安全策略

**策略：通过 TypeScript 泛型在编译时强制租户约束**

```typescript
// 定义强制约束类型
export type EnforceOrgId = { _organizationId: OrganizationId };
export type EnforceEnvId = { _environmentId: EnvironmentId };

// BaseRepository 泛型约束
export class BaseRepository<T_DBModel, T_MappedEntity, T_Enforcement> {
  async findOne(
    query: FilterQuery<T_DBModel> & T_Enforcement  // ★ 编译时强制
  ): Promise<T_MappedEntity | null>;
}

// 具体实现
export class MessageRepository extends BaseRepository<
  MessageDBModel,
  MessageEntity,
  EnforceEnvId  // ★ 强制必须包含 _environmentId
> {}

// 使用时
const messages = await messageRepository.find({
  _environmentId: 'env-123',  // ★ 必须包含，否则编译失败
  // ... 其他条件
});
```

**优势：**
- 编译时检查，不是运行时检查
- 开发者无法遗漏隔离字段
- 重构时自动发现遗漏

### 2.2 认证安全策略

```
┌─────────────────────────────────────────────────────────────────────┐
│                        认证安全策略                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   JWT 认证                                                           │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   • Token 过期时间：2 小时                                    │  │
│   │   • 刷新机制：支持 Token 刷新                                 │  │
│   │   • Claims 包含：organizationId, roles, permissions          │  │
│   │   • 环境选择：通过 HTTP Header 传递                           │  │
│   │   • 跨组织切换：生成新 Token                                  │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   API Key 认证                                                       │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   • 存储加密：AES-256 加密存储                                │  │
│   │   • 查询优化：SHA256 哈希索引                                 │  │
│   │   • 缓存策略：LRU 缓存，减少 DB 查询                          │  │
│   │   • 环境绑定：API Key 与环境一对一                            │  │
│   │   • 过期机制：支持设置过期时间                                 │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.3 权限检查策略

```typescript
// 差异化权限检查策略
async canActivate(context: ExecutionContext): Promise<boolean> {
  const organization = await this.getOrganization(user.organizationId);
  
  switch (organization.apiServiceLevel) {
    case ApiServiceLevelEnum.FREE:
    case ApiServiceLevelEnum.PRO:
      // Free/Pro 层级：跳过权限检查
      return true;
      
    case ApiServiceLevelEnum.BUSINESS:
    case ApiServiceLevelEnum.ENTERPRISE:
      // Business/Enterprise 层级：强制权限检查
      return this.checkPermissions(user.permissions, requiredPermissions);
      
    default:
      return false;
  }
}
```

**策略优势：**
- 免费用户体验友好（无权限限制）
- 企业客户满足合规要求（严格权限）
- 按服务等级差异化功能

---

## 三、性能优化策略

### 3.1 索引策略

```typescript
// 复合索引设计原则
// 1. 隔离字段在前
// 2. 查询条件在中
// 3. 排序字段在后

// 消息查询索引
messageSchema.index({
  _environmentId: 1,    // 隔离字段
  _subscriberId: 1,     // 查询条件
  contextKeys: 1,       // 上下文过滤
  createdAt: -1,        // 排序
});

// 工作流查询索引
notificationTemplateSchema.index({
  _environmentId: 1,                // 隔离字段
  'triggers.identifier': 1,         // 查询条件
});

// 集成查询索引
integrationSchema.index({
  _organizationId: 1,   // 隔离字段
  active: 1,            // 过滤条件
});
```

### 3.2 缓存策略

```
┌─────────────────────────────────────────────────────────────────────┐
│                        缓存策略                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   API Key 缓存                                                       │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   缓存层：LRU 内存缓存                                        │  │
│   │   Key：SHA256(apiKey)                                        │  │
│   │   Value：UserSessionData                                     │  │
│   │   TTL：5 分钟                                                 │  │
│   │   失效：API Key 撤销时主动清除                                │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   组织信息缓存                                                       │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   缓存层：Redis                                               │  │
│   │   Key：org:{organizationId}                                  │  │
│   │   Value：OrganizationEntity                                  │  │
│   │   TTL：10 分钟                                                │  │
│   │   失效：组织信息更新时主动清除                                │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
│   权限缓存                                                           │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │   缓存层：JWT Token 本身                                      │  │
│   │   Key：N/A（存储在 Token Claims 中）                         │  │
│   │   Value：roles, permissions                                  │  │
│   │   TTL：与 JWT Token 相同（2 小时）                           │  │
│   │   失效：Token 过期或重新签发                                  │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 查询优化策略

```typescript
// 1. 使用读偏好优化
async find(query, select, options) {
  return this.MongooseModel.find(query, select, {
    readPreference: 'secondaryPreferred',  // 优先从副本读取
    ...options,
  });
}

// 2. 分页优化：使用游标分页而非偏移分页
async findWithCursorBasedPagination(options) {
  const { query, limit, after, orderBy } = options;
  
  if (after) {
    query._id = { $gt: after };  // 使用 _id 作为游标
  }
  
  return this.find(query, '', { limit: limit + 1, sort: { [orderBy]: -1 } });
}

// 3. 批量查询优化
async findBatch(query, batchSize = 1000) {
  const cursor = this.MongooseModel.find(query).batchSize(batchSize).lean();
  
  for await (const doc of cursor) {
    yield this.mapEntity(doc);
  }
}
```

---

## 四、可扩展性策略

### 4.1 水平分片策略（未来）

```
┌─────────────────────────────────────────────────────────────────────┐
│                      水平分片策略                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   分片键选择：_organizationId                                        │
│                                                                      │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                       Mongos Router                          │  │
│   └───────────────────────────┬─────────────────────────────────┘  │
│                               │                                      │
│           ┌───────────────────┼───────────────────┐                │
│           │                   │                   │                │
│           ▼                   ▼                   ▼                │
│   ┌───────────────┐   ┌───────────────┐   ┌───────────────┐       │
│   │   Shard 1     │   │   Shard 2     │   │   Shard 3     │       │
│   │               │   │               │   │               │       │
│   │ org_1 ~ org_n │   │ org_n+1 ~     │   │ org_m+1 ~     │       │
│   │               │   │   org_m       │   │   org_x       │       │
│   └───────────────┘   └───────────────┘   └───────────────┘       │
│                                                                      │
│   优势：                                                             │
│   • 单组织查询路由到单一分片，性能最优                               │
│   • 跨组织查询需要 scatter-gather，但场景较少                       │
│   • 组织间数据完全物理隔离                                           │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.2 多区域部署策略

```
┌─────────────────────────────────────────────────────────────────────┐
│                      多区域部署策略                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   策略：按组织区域路由                                               │
│                                                                      │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │                       Global Load Balancer                   │  │
│   └───────────────────────────┬─────────────────────────────────┘  │
│                               │                                      │
│           ┌───────────────────┼───────────────────┐                │
│           │                   │                   │                │
│           ▼                   ▼                   ▼                │
│   ┌───────────────┐   ┌───────────────┐   ┌───────────────┐       │
│   │   US Region   │   │   EU Region   │   │   APAC Region │       │
│   │               │   │               │   │               │       │
│   │ US Orgs       │   │ EU Orgs       │   │ APAC Orgs     │       │
│   │ (org.region=  │   │ (org.region=  │   │ (org.region=  │       │
│   │  'us')        │   │  'eu')        │   │  'apac')      │       │
│   └───────────────┘   └───────────────┘   └───────────────┘       │
│                                                                      │
│   实现要点：                                                         │
│   • Organization 实体增加 region 字段                               │
│   • DNS 根据组织区域解析到对应集群                                   │
│   • 跨区域数据异步复制（合规要求时）                                 │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 五、可借鉴的设计模式

### 5.1 泛型约束模式

```typescript
/**
 * 通过泛型参数在类型层面强制所有数据库操作带上租户过滤条件
 * 
 * 优势：
 * 1. 编译时检查，不是运行时
 * 2. 开发者无法遗漏隔离字段
 * 3. 代码即文档
 */

// 定义约束类型
type EnforceTenant<TenantField extends string> = { [K in TenantField]: string };

// 应用到 Repository
class TenantAwareRepository<
  TModel,
  TEntity,
  TTenantField extends string
> extends BaseRepository<
  TModel,
  TEntity,
  EnforceTenant<TTenantField>
> {
  // 所有方法自动带上约束
}
```

### 5.2 装饰器驱动模式

```typescript
/**
 * 通过装饰器声明式地表达权限需求
 * 
 * 优势：
 * 1. 关注点分离：业务代码与权限代码分离
 * 2. 可读性强：一眼看出 API 需要什么权限
 * 3. 易于维护：修改权限只需修改装饰器
 */

@Controller('workflows')
export class WorkflowController {
  @Post()
  @RequirePermissions(PermissionsEnum.WORKFLOW_WRITE)
  create(@Body() dto: CreateWorkflowDto) {
    // 业务逻辑
  }

  @Get()
  @RequirePermissions(PermissionsEnum.WORKFLOW_READ)
  findAll() {
    // 业务逻辑
  }
}
```

### 5.3 Command 模式

```typescript
/**
 * 所有 UseCase 通过 Command 对象接收参数
 * Command 基类强制包含租户信息
 * 
 * 优势：
 * 1. 参数类型安全
 * 2. 自动验证
 * 3. 租户信息强制传递
 */

abstract class TenantAwareCommand {
  abstract organizationId: string;
  abstract environmentId: string;
}

class CreateWorkflowCommand extends TenantAwareCommand {
  organizationId: string;
  environmentId: string;
  
  name: string;
  steps: Step[];
}
```

### 5.4 上下文传递模式

```typescript
/**
 * 通过装饰器从请求中提取用户会话
 * 
 * 优势：
 * 1. 依赖注入，易于测试
 * 2. 类型安全
 * 3. 自动文档生成
 */

@Controller('workflows')
export class WorkflowController {
  @Post()
  create(
    @UserSession() user: UserSessionData,  // 自动注入
    @Body() dto: CreateWorkflowDto
  ) {
    return this.useCase.execute({
      organizationId: user.organizationId,
      environmentId: user.environmentId,
      ...dto,
    });
  }
}
```

---

## 六、最佳实践总结

### 6.1 Do（推荐）

| 实践 | 说明 |
|:---|:---|
| ✅ 使用泛型约束 | 编译时强制租户隔离 |
| ✅ 复合索引 | 隔离字段作为索引前缀 |
| ✅ 缓存 API Key | 减少 DB 查询 |
| ✅ 差异化权限 | 按服务等级调整策略 |
| ✅ 审计日志 | 记录跨租户访问 |

### 6.2 Don't（避免）

| 实践 | 说明 |
|:---|:---|
| ❌ 跳过泛型约束 | 破坏类型安全 |
| ❌ 单字段索引 | 导致全表扫描 |
| ❌ 硬编码租户 ID | 代码耦合 |
| ❌ 跨租户查询 | 无显式声明时禁止 |
| ❌ 明文存储 API Key | 安全风险 |

### 6.3 性能优化清单

- [ ] 隔离字段建立复合索引
- [ ] 使用读副本分担读压力
- [ ] API Key 使用 LRU 缓存
- [ ] 大数据量使用游标分页
- [ ] 避免跨租户聚合查询

### 6.4 安全检查清单

- [ ] 所有 Repository 使用泛型约束
- [ ] API Key 加密存储
- [ ] JWT 过期时间合理
- [ ] 权限检查覆盖所有 API
- [ ] 审计日志完整记录

---

*文档版本：1.0*  
*更新时间：2026-02-22*
